# -*- coding: utf-8 -*-
"""Taller1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gy8i-GuF18a1yAXaYMSXm6hznHlGnPv3

# TALLER DE ALGORITMOS


---

Actividad 1
"""

import math
import numpy as np
import pylab as pl
import time
# %matplotlib inline

class Counter:
    def __init__(self):
        self.steps = 0

    def reset(self):
        self.steps = 0

    def count(self):
        self.steps += 1

    def print_steps(self):
        print ("Number of steps =", self.steps)
        
def acct_insertion_sort(A, acct):
    j = 1; acct.count()                               #      1
    acct.count()
    while j < len(A):                                 #      n
        acct.count()
        key = A[j]; acct.count()                      #      1
        i = j - 1; acct.count()                       #      1
        acct.count()
        while (i >= 0) and (A[i] > key):              #      n
            acct.count()
            A[i + 1] = A[i]; acct.count()             #      1
            i = i -1; acct.count()                    #      1
        A[i + 1] = key; acct.count()                  #      1
        j = j + 1; acct.count()                       #      1
                                                      #   --------
                                                      # T(n)=n^2  Complexity of the insertion sort algorithm.

def exper_analysis(n):
    tic = time.clock()#get start time
    results = []
    acct = Counter()
    for i in range(n):
        B = np.random.permutation(range(0,i))
        acct.reset()
        acct_insertion_sort(B, acct)
        results.append(acct.steps)
    toc = time.clock()#get final time
    print("Final time=",toc)
    return results

pl.clf()
x = np.arange(100)
y = np.array(exper_analysis(100))
pl.plot(x, y, 'k.')

"""---
Actividad 2
"""

class Counter:
    def __init__(self):
        self.steps = 0

    def reset(self):
        self.steps = 0

    def count(self):
        self.steps += 1

    def print_steps(self):
        print ("Number of steps =", self.steps)
        
def mergeSort(alist, acct):
    acct.count()
    if len(alist)>1:                                         #     1
        acct.count()              
        mid = len(alist)//2                                  #     1
        acct.count()
        lefthalf = alist[:mid]                               #     1
        acct.count()
        righthalf = alist[mid:]                              #     1
        acct.count()
        mergeSort(lefthalf, acct)                            #     1
        acct.count()
        mergeSort(righthalf, acct)                           #     1
        acct.count()
        i=0                                                  #     1
        j=0                                                  #     1
        k=0                                                  #     1
        acct.count()
        while i < len(lefthalf) and j < len(righthalf):      #     n
            acct.count()
            if lefthalf[i] < righthalf[j]:                   #     1
                acct.count()
                alist[k]=lefthalf[i]                         #     1
                acct.count()
                i=i+1                                        #     1
            else:
                acct.count()
                alist[k]=righthalf[j]                        #     1
                acct.count()
                j=j+1                                        #     1
            acct.count()
            k=k+1                                            #     1
            acct.count()
        while i < len(lefthalf):                             #     n
            acct.count()
            alist[k]=lefthalf[i]                             #     1
            acct.count()
            i=i+1                                            #     1
            acct.count()
            k=k+1                                            #     1
            acct.count()
        while j < len(righthalf):                            #     n
            acct.count()
            alist[k]=righthalf[j]                            #     1
            acct.count()
            j=j+1                                            #     1
            acct.count()
            k=k+1                                            #     1
                                                           # ---------------
                                                           # T(n)=O(nLogn)
            
def exper_analysis(n):
    tic = time.clock()#get start time
    results = []
    acct = Counter()
    for i in range(n):
        B = np.random.permutation(range(0,i))
        acct.reset()
        mergeSort(B,acct)
        results.append(acct.steps)
    toc = time.clock()#get final time
    print("Final time=",toc)
    return results

pl.clf()
x = np.arange(100)
y = np.array(exper_analysis(100))
pl.plot(x, y, 'k.')

"""---

Actividad 3
"""

class Counter:
    def __init__(self):
        self.steps = 0

    def reset(self):
        self.steps = 0

    def count(self):
        self.steps += 1

    def print_steps(self):
        print ("Number of steps =", self.steps)
        
def quickSort(alist, acct):
    acct.count()
    quickSortHelper(alist,0,len(alist)-1,acct)

def quickSortHelper(alist,first,last,acct):
    acct.count()
    if first<last:
        acct.count()
        splitpoint = partition(alist,first,last,acct)
        acct.count()
        quickSortHelper(alist,first,splitpoint-1,acct)
        acct.count()
        quickSortHelper(alist,splitpoint+1,last,acct)

def partition(alist,first,last,acct):
    acct.count()                                                      #      1
    pivotvalue = alist[first]                                         #      1
    acct.count()
    leftmark = first+1                                                #      1
    acct.count()
    rightmark = last                                                  #      1
    
    acct.count()
    done = False                                                      #      1
    acct.count()
    while not done:                                                   #      n
        acct.count()
        while leftmark <= rightmark and alist[leftmark] <= pivotvalue:#      n
            acct.count()
            leftmark = leftmark + 1                                   #      1
            acct.count()
        while alist[rightmark] >= pivotvalue and rightmark >= leftmark:#     n
            acct.count()
            rightmark = rightmark -1                                  #      1
            acct.count()
        if rightmark < leftmark:                                      #      1
            acct.count()
            done = True                                               #      1
            acct.count()
        else:
            acct.count()
            temp = alist[leftmark]                                    #      1
            acct.count()
            alist[leftmark] = alist[rightmark]                        #      1
            acct.count()
            alist[rightmark] = temp                                   #      1
            acct.count()                                              # ------------
                                                                      #T(n)=O(nLogn)   Peor de los Casos T(n)=O(n^2)
    temp = alist[first]
    acct.count()
    alist[first] = alist[rightmark]
    acct.count()
    alist[rightmark] = temp
    acct.count()
    return rightmark

def exper_analysis(n):
    tic = time.clock()#get start time
    results = []
    acct = Counter()
    for i in range(n):
        B = np.random.permutation(range(0,i))
        acct.reset()
        quickSort(B, acct)
        results.append(acct.steps)
    toc = time.clock()#get final time
    print("Final time=",toc)
    return results

pl.clf()
x = np.arange(100)
y = np.array(exper_analysis(100))
pl.plot(x, y, 'k.')

"""---

# Conclusiones


```
# El algoritmo de ordenamiento quickSort tomo menos tiempo que el inserSort y MergeSort.
# El algorito de ordenamiento quickSort, en la grafica tiene una linea más recta e inclinada.
# El ordenamiento por inserción es más eficiente si el arreglo esta casi ordenado.

```
"""